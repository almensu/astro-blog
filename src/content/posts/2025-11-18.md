---
title: 把脏活留给 AI：我只定义了 Input 和 Output， 从 Claude code 丝滑切换国产模型
date: 2025-11-18
summary: Claude Code 很强，但它的第三方模型配置逻辑却“简陋”得令人发指——你只能通过一个环境变量死死锁定一个模型。想在“顶配 Sonnet”和“平价 DeepSeek”之间切换？请手动改文件。本文记录了我如何用 fzf 和 awk 给终端手搓了一个“一键换挡”功能。
category: 终端工具开发
tags: [Claude Code, fzf, awk, 终端自动化, 模型切换, 生产力工具, Zsh技巧]
---

摘要：Claude Code 很强，但它的第三方模型配置逻辑却“简陋”得令人发指——你只能通过一个环境变量死死锁定一个模型。想在“顶配 Sonnet”和“平价 DeepSeek”之间切换？请手动改文件。本文记录了我如何用 fzf 和 awk 给终端手搓了一个“一键换挡”功能。

## 01. 那个“只能选一个”的荒谬设定

最近 Claude Code（Anthropic 官方出的那个 CLI 神器）彻底改变了我的开发流。它能读代码、能改 bug、甚至能直接跑测试，确实有点“贾维斯”雏形的意思了。

尤其是配合 SiliconFlow（硅基流动）这样的第三方 API 转发服务，让我们能用极低的延迟和成本在终端里跑 DeepSeek 或者 Qwen。一切看起来都很美好，直到——

我发现它有一个极其反人性的设定：它只能“单恋”一个模型。

Claude Code 的第三方模型支持，完全依赖于环境变量 `export ANTHROPIC_MODEL=...`。这意味着，在任意时刻，你的终端里只能存在唯一一个第三方生效的模型配置。官方文档仿佛在说：“亲爱的用户，请在配置文件里写死它。”

这就很尴尬了。我的需求从来不是静态的，而是动态波动的：

- 改核心架构时：我需要 Claude 4.5 Sonnet。它逻辑严密、指令遵循度高，哪怕贵点也值得，这是解决难题的“重武器”。
- 写简单脚本/解释报错时：我需要 DeepSeek-V3 或 Qwen。它便宜、速度快、够用，这是日常搬砖的“轻工具”。

但在目前的机制下，要想从“重武器”切换到“轻工具”，我竟然需要：

1. 停下手里的活。
2. 打开 `~/.zshrc`。
3. 像个外科医生一样，小心翼翼地把一行注释掉（#），再把另一行解开注释。
4. `:wq` 保存，`source` 重载。

都 2025 年了，我竟然还要通过“手动修改文本文件”来切换软件的一个基本设置？ 这简直就像是开法拉利，但每次换挡都得下车手动搬齿轮。

## 02. 既然官方不给，那就自己造个“离合器”

这种“摩擦力”在一天几十次的调用中被无限放大。我不想每次为了省几块钱 Token 费就去改配置，也不想为了图省事就一直挂着昂贵的 Sonnet 烧钱。

我需要的，是一个能在终端里毫秒级切换的“离合器”。

我的需求很简单，把流程自动化：

1. 读取（Read）：把我在 `.zshrc` 里预设好的那堆 `#export ANTHROPIC_MODEL=` 模型全列出来。
2. 选择（Select）：弹个窗让我选这次用哪个。
3. 生效（Apply）：自动改文件、自动生效，然后直接把 Claude 给我启动起来。

于是，我盯着终端里的 fzf（模糊搜索神器）和 awk（文本处理手术刀），意识到解决这个问题的钥匙就在它们身上。

## 03. 解构：把配置文件当数据库

要实现“原位手术”，我们需要构建一个闭环的自动化流。

### 第一步：用 awk “透视”文件

我们需要找出所有 `export ANTHROPIC_MODEL=` 的行，无论它前面有没有 `#`。同时，我们要标记出哪一个是“当前正在用”的。

```bash
# 提取逻辑预览
awk '
  /export[[:space:]]+ANTHROPIC_MODEL=/ {
    # 如果行首没有 #，就是[当前]；否则是[备选]
    status = ($0 ~ /^[[:space:]]*export/) ? "[当前]" : "[备选]"
    # 打印：行号 状态 原文
    printf "%5d %s %s\n", NR, status, $0
  }' ~/.zshrc
```

这一步把混乱的文本变成了结构化数据，为下一步的 fzf 喂食做好了准备。

### 第二步：用 fzf “折叠”复杂度

fzf 不仅仅是搜索工具，它是终端里最好的“选择器”。我们将上一步的输出通过管道喂给 fzf：

```bash
fzf --header="[当前]=启用 [备选]=注释" --preview='echo {}'
```

这样，我就能在几毫秒内通过上下键选中我想要的目标，而不需要关心它在文件的第几行。

### 第三步：用 awk 执行“原位手术”

这是最关键的一步。拿到用户选中的行号（target）后，我们需要生成一个新的配置文件。逻辑必须非常严谨：

- 选中行必须去掉注释。
- 其他模型行必须加上注释（防止多重定义）。
- 其他无关行 保持原样。

## 04. 最终成品：cc 函数

我将上述逻辑封装成了一个 Zsh 函数 `cc` (Claude Changer)。

### 食用方法：

1. 确保你安装了 fzf (`brew install fzf`)。
2. 把下面这段代码完整复制到你的 `~/.zshrc` 文件末尾。
3. 执行一次 `source ~/.zshrc`。

```zsh
cc() {
  emulate -L zsh    # 确保在 zsh 语义下执行
  local zshrc="$HOME/.zshrc"
  local cwd="$PWD"

  # --- 1. 依赖与文件检查 ---
  if ! command -v fzf >/dev/null 2>&1; then
    echo "❌ 未找到 fzf，请先安装：brew install fzf" >&2
    return 1
  fi

  if [[ ! -f "$zshrc" ]]; then
    echo "❌ 找不到 $zshrc" >&2
    return 1
  fi

  # --- 2. 提取所有配置（带状态标记） ---
  local choices
  choices=$(awk '
    /export[[:space:]]+ANTHROPIC_MODEL=/ {
      # 判断行首是否有 #，决定是[当前]还是[备选]
      status = ($0 ~ /^[[:space:]]*export[[:space:]]+ANTHROPIC_MODEL=/) ? "[当前]" : "[备选]"
      printf "%5d %s %s\n", NR, status, $0
    }' "$zshrc")

  if [[ -z "$choices" ]]; then
    echo "❌ 在 .zshrc 里没找到 ANTHROPIC_MODEL 配置。" >&2
    return 1
  fi

  # --- 3. fzf 交互选择 ---
  local selection
  selection=$(printf '%s\n' "$choices" | fzf \
      --prompt="🔮 选择模型 > " \
      --header="提示：[当前]=启用 [备选]=注释" \
      --height=40% \
      --layout=reverse)

  # 如果按 ESC 取消，直接退出
  if [[ -z "$selection" ]]; then
    echo "已取消。"
    return 0
  fi

  # --- 4. 解析行号并修改文件 ---
  local lineno
  lineno=$(echo "$selection" | awk '{print $1}')

  # 创建临时文件
  local tmp
  tmp=$(mktemp "${TMPDIR:-/tmp}/anthropic_model.XXXXXX")

  # awk 核心逻辑：选中行去注释，其他模型行加注释
  awk -v target="$lineno" '
    NR==target {
      sub(/^[[:space:]]*#?[[:space:]]*/, "", $0) # 去掉开头的 # 和空格
      sub(/^export[[:space:]]+ANTHROPIC_MODEL=/, "export ANTHROPIC_MODEL=", $0) # 规范化
      print
      next
    }
    /export[[:space:]]+ANTHROPIC_MODEL=/ {
      sub(/^[[:space:]]*#?[[:space:]]*/, "#", $0) # 强制加 #
      print
      next
    }
    { print } # 其他行原样输出
  ' "$zshrc" > "$tmp"

  # 覆盖原文件
  mv "$tmp" "$zshrc"

  # --- 5. 生效与启动 ---
  source "$zshrc"
  cd "$cwd" || true # source 可能会重置目录，跳回当前工作目录

  echo "✅ 已切换为：${ANTHROPIC_MODEL}"

  # 自动启动 Claude (根据你本地的命令名修改，比如 claude-code 或 ac)
  if command -v claude >/dev/null 2>&1; then
    echo "🚀 启动 Claude..."
    claude "$@"
  else
    echo "⚠️ 切换成功，但未找到 claude 命令，请手动启动。"
  fi
}
```

### 效果演示：

现在，我的 `.zshrc` 里可以放心地堆满各种模型配置。当我觉得 Qwen 稍微有点“笨”了，想换回 DeepSeek 或者 Sonnet 时，只需要敲 `cc`，上下键选择，回车。

世界安静了。脚本自动完成了注释修改、配置重载，并直接帮我打开了 Claude。

## 05. 偷懒的艺术：Prompt 即源码

说句实话，上面那段复杂的 awk 处理逻辑，我一行都没手写——毕竟谁能记得住 awk 那些反人类的语法呢？

写这个脚本的全程，我只做了一件事：把需求用人类语言讲清楚。

这是我生成这段代码时使用的原始提示词，你可以直接把它丢给 Gemini：

> - 在 macOS 下写一个 zsh 函数 `cc`，用正则匹配 `export ANTHROPIC_MODEL=` 和 `#export ANTHROPIC_MODEL=`，通过 `fzf` 列出所有模型配置。
> - 在 `fzf` 中选中某一行后，将该行自动去掉注释、其他同类行全部加上 `#` 注释，写回 `~/.zshrc` 并 `source ~/.zshrc` 生效。
> - 保持当前目录不变，最后自动执行本地的 Claude 启动命令，实现“一键切换模型并开启 Claude”。

你会发现，只要你的逻辑像上面这样结构清晰（环境 + 动作 + 预期结果），AI 就能帮你搞定剩下 99% 的脏活累活。

## 06. 所以呢？

这一代普通人最大的红利，不是 GitHub Copilot 能帮你补全多少行代码，而是从想法到工具的路径被无限缩短了。

- 以前的门槛：是你必须精通 Zsh 语法、正则表达和 awk 的流处理逻辑，才能动手解决这个痛点。因为门槛太高，大多数人选择忍受“手动改配置”的麻烦。
- 现在的门槛：是你能不能精准地提出问题。

这段 50 行的代码并不值钱，值钱的是那 3 行提示词。

在这个时代，如果你能清晰地描述一个问题，你就已经解决了这个问题的一半。 不要在意你是用 Python 还是 Shell，也不要在意你记不记得住语法，把精力花在定义需求和设计流程上。

别再去死记硬背那些生僻的命令了。下次遇到繁琐的重复劳动，试着停下来，对 AI 说：“嘿，我想做件事，逻辑是这样的……”

你会发现，你的终端里，其实藏着无限的可能性。

## 07. 写在最后：寻找那些“用自然语言编程”的同类

这篇文章发出来，可能很多人会把目光停留在那个 awk 脚本上，觉得“哇，这个脚本写得挺溜”。

但在我看来，那 50 行代码其实是可抛弃的耗材。真正有价值的，是那段只有 100 来字的提示词（Prompt）。

如果你读到这里，比起直接拿走我的脚本，你更对如何写出那段提示词感兴趣，那么我们要找的同类就是你。

我们可能不再以“掌握多少生僻语法”为荣，而是开始痴迷于如何用最精准的自然语言，把一个模糊的需求“编译”成机器能懂的指令。

你是不是也觉得，现在的编程本质上变成了“沟通”？

你有没有那一刻，通过调整了一个动词或加了一个上下文限制，突然让 AI 吐出了完美的代码，那种快感不亚于当年第一次跑通 Hello World？

我很想认识更多像你这样的人。

在评论区聊聊吧：你最近有没有写过一个让自己都觉得惊艳的 Prompt？ 或者，你有没有遇到过一个怎么描述 AI 都听不懂的顽固场景？
